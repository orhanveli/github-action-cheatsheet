name: Cleanup Old Docker Images

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *" # every day

jobs:
  clean:
    runs-on: ubuntu-latest
    permissions:
      packages: write
    name: Delete old test images
    steps:
      - name: Delete old container images
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const packageName = 'your-package-name';
            const keepHashTaggedCount = 5;

            // Tags to always preserve (semantic versions, branch names)
            const isProtectedTag = (tag) => {
              // Keep semantic versions like 1.0.0, 1.0.1, v1.2.3, etc.
              if (/^v?\d+\.\d+(\.\d+)?$/.test(tag)) return true;
              // Keep branch tags
              if (['latest', 'main', 'master', 'develop', 'development'].includes(tag)) return true;
              return false;
            };

            // Check if tag looks like a commit hash (7+ hex characters)
            const isHashTag = (tag) => /^[a-f0-9]{7,40}$/.test(tag);

            // Get all versions
            const versions = await github.paginate(
              github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg,
              {
                org: owner,
                package_type: 'container',
                package_name: packageName,
                per_page: 100
              }
            );

            console.log(`Found ${versions.length} total versions`);

            // Categorize versions
            const protectedVersionIds = new Set();
            const hashTaggedVersions = [];
            const untaggedVersions = [];

            for (const v of versions) {
              const tags = v.metadata?.container?.tags || [];

              if (tags.length === 0) {
                untaggedVersions.push(v);
                continue;
              }

              // Check if any tag is protected
              const hasProtectedTag = tags.some(isProtectedTag);
              if (hasProtectedTag) {
                protectedVersionIds.add(v.id);
                console.log(`Protected (version/branch tag): ${tags.join(', ')}`);
                continue;
              }

              // Check if it only has hash tags
              const allHashTags = tags.every(isHashTag);
              if (allHashTags) {
                hashTaggedVersions.push(v);
              } else {
                // Unknown tag pattern - protect it to be safe
                protectedVersionIds.add(v.id);
                console.log(`Protected (unknown tag pattern): ${tags.join(', ')}`);
              }
            }

            console.log(`Protected versions: ${protectedVersionIds.size}`);
            console.log(`Hash-tagged versions: ${hashTaggedVersions.length}`);
            console.log(`Untagged versions: ${untaggedVersions.length}`);

            // Sort hash-tagged by date, keep latest N
            const sortedHashTagged = hashTaggedVersions.sort((a, b) =>
              new Date(b.created_at) - new Date(a.created_at)
            );

            const hashTaggedToDelete = sortedHashTagged.slice(keepHashTaggedCount);
            console.log(`Will delete ${hashTaggedToDelete.length} old hash-tagged versions`);

            for (const v of hashTaggedToDelete) {
              const tags = v.metadata?.container?.tags || [];
              console.log(`Deleting hash-tagged: ${tags.join(', ')} (${v.id})`);
              try {
                await github.rest.packages.deletePackageVersionForOrg({
                  org: owner,
                  package_type: 'container',
                  package_name: packageName,
                  package_version_id: v.id
                });
              } catch (err) {
                console.log(`Failed to delete ${v.id}: ${err.message}`);
              }
            }

            // Delete all untagged versions (these are usually orphaned layers)
            console.log(`Will delete ${untaggedVersions.length} untagged versions`);

            for (const v of untaggedVersions) {
              console.log(`Deleting untagged: ${v.id}`);
              try {
                await github.rest.packages.deletePackageVersionForOrg({
                  org: owner,
                  package_type: 'container',
                  package_name: packageName,
                  package_version_id: v.id
                });
              } catch (err) {
                console.log(`Failed to delete ${v.id}: ${err.message}`);
              }
            }

            console.log('Cleanup complete!');
